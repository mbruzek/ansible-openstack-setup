---
- name: The steps to set up one server in a new OpenStack environment.
  hosts: localhost
  vars:
    image_server: "{{ lookup('env', 'image_server') }}"
    image_server_user: "{{ lookup('env', 'image_server_user') }}"
    keypair_name: "{{ lookup('env', 'keypair_name') | default('keypair1') }}"
    network_name: "{{ lookup('env', 'network_name') | default('network1') }}"
    openstack_location: ""
    openstack_rc: "{{ lookup('env', 'openstack_rc_path') }}"
    private_key_path: "{{ lookup('env', 'private_key_path') }}"
    public_key_path: "{{ lookup('env', 'public_key_path') }}"
    public_network_name: "{{ lookup('env', 'public_network_name') }}"
    public_subnet_name: "{{ lookup('env', 'public_subnet_name') }}"
    router_name: "{{ lookup('env', 'router_name') }}"
    security_group_name: "{{ lookup('env', 'security_group_name') }}"
    server_flavor: "{{ lookup('env', 'server_flavor') }}"
    server_image: "{{ lookup('env', 'server_image') }}"
    server_name: "{{ lookup('env', 'server_name') }}"
    server_user: "{{ lookup('env', 'server_user') }}"
    subnet_name: "{{ lookup('env', 'subnet_name') | default('subnet1') }}"
    subnet_range: "{{ lookup('env', 'subnet_range') | default('192.168.4. 0/24') }}"
    standard_flavors:
      - { name: m1.small, vcpu: 1, memory: 1740, disk: 40 }
      - { name: m1.medium, vcpu: 1, memory: 3840, disk: 80 }
      - { name: m1.large, vcpu: 2, memory: 7680, disk: 120 }
      - { name: m4.large, vcpu: 2, memory: 8192, disk: 50 }
      - { name: m4.xlarge, vcpu: 4, memory: 16384, disk: 100 }
      - { name: m4.2xlarge, vcpu: 8, memory: 32768, disk: 200 }
      - { name: m4.4xlarge, vcpu: 16, memory: 65536, disk: 300 }
      - { name: m4.10xlarge, vcpu: 40, memory: 163840, disk: 500 }
    openshift_flavors:
      - { name: container_storage, vcpu: 16, memory: 65536, disk: 128 }
      - { name: load_balancer, vcpu: 4, memory: 16384, disk: 128 }
      - { name: infra_elastic, vcpu: 16, memory: 65536, disk: 128 }
      - { name: master_etcd, vcpu: 64, memory: 245760, disk: 512 }
      - { name: node_small, vcpu: 1, memory: 2048, disk: 32 }
      - { name: node_average, vcpu: 4, memory: 16384, disk: 64 }
    delete_images: false
    qcow2_images:
      - name: fedora26
        checksum: sha256:37a621dda65b04e8b6eee207088ff7697795cb2affdac13ed77166453989557c
        url: https://download.fedoraproject.org/pub/fedora/linux/releases/26/CloudImages/x86_64/images/Fedora-Cloud-Base-26-1.5.x86_64.qcow2

  tasks:

    - block:
        # Install the common operating system packages.
        - name: Install common packages
          package:
            name: "{{ item }}"
            state: latest
          with_items:
            - gcc
            - libselinux-python
            - redhat-rpm-config
          become: true
        # Ensure the Fedora packages are installed.
        - name: Installing the Fedora packages
          package:
            name: "{{ item }}"
            state: latest
          when: ansible_distribution == "Fedora"
          with_items:
            - python2-devel
            - python2-virtualenv
          become: true
        # Ensure the CentOS or RHEL packages are installed
        - name: Installing the CentOS or RHEL packages
          package:
            name: "{{ item }}"
            state: latest
          when: ansible_distribution == "CentOS" or ansible_distribution == "RedHat"
          with_items:
            - python-devel
            - python-virtualenv
          become: true

        # Create a virtual Python environment.
        - name: Creating a virtual Python environment to install requirements
          command: virtualenv virtualenv

        # Need the OpenStack client to create a server that will install everything.
        - name: Installing the Python packages in the virtual environment
          # The version 3.12.0 has some errors when running these commands.
          shell: "virtualenv/bin/pip install -U {{ item }}"
          with_items:
            - pip
            - python-openstackclient==3.11.0
            - python-heatclient

        # Check the virtualenv for the openstack client
        - name: Checking the virtualenv for the openstack client
          stat:
            path: "virtualenv/bin/openstack"
          register: openstack_venv

        # When the file exists set the openstack location.
        - name: Setting the openstack client location to the virtualenv
          set_fact:
            openstack_location: "{{ openstack_venv.stat.path }}"
          when: openstack_venv.stat.exists and openstack_venv.stat.executable

    - name: Setting openstack location
      set_fact:
        openstack: "source {{ openstack_rc }}; {{ openstack_location|default('openstack') }}"

    # Create a router so the private network can connect to the Internet.
    - name: Creating the {{ router_name }} router
      shell: "{{ openstack }} router create {{ router_name }} --format value -c id"
      register: router_uuid
      ignore_errors: yes

    # Create a private network for the OpenStack servers to use.
    - name: Creating the {{ network_name }} network
      shell: "{{ openstack }} network create {{ network_name }} --format value -c id"
      register: private_network_uuid

    # Run a command to retrieve the public DNS nameservers already set up.
    - name: Getting the dns_nameservers addresses from the {{ public_subnet_name }}
      shell: "{{ openstack }} subnet show {{ public_subnet_name }} --format value -c dns_nameservers"
      register: dns_nameservers

    # Create a subnet with a CIDR range and link it to the private network.
    - name: Creating the {{ subnet_name }} subnet
      shell: "{{ openstack }} subnet create --network {{ network_name }} --subnet-range {{ subnet_range }} {{ subnet_name }} --format value -c id"
      register: subnet_uuid

    # Set each DNS server on the subnet of the private network.
    - name: Setting the DNS nameservers on {{ subnet_name }}
      shell: "{{ openstack }} subnet set --dns-nameserver {{ item }} {{ subnet_name }}"
      with_items: "{{ dns_nameservers.stdout }}"

    # The subnet is configured, add it to the router.
    - name: Adding {{ subnet_name }} subnet to the {{ router_name }} router
      shell: "{{ openstack }} router add subnet {{ router_name }} {{ subnet_uuid.stdout }}"

    # Run a command to retrieve the public network uuid.
    - name: Getting the public network id
      shell: "{{ openstack }} network show {{ public_network_name }} --format value -c id"
      register: public_network_uuid

    # Set the gateway on the new router to use the public network.
    - name: Assigning the public network as the gateway for the new router
      #shell: virtualenv/bin/neutron router-gateway-set {{ router_uuid.stdout }} {{ public_network_uuid.stdout }}
      shell: "{{ openstack }} router set {{ router_uuid.stdout }} --external-gateway {{ public_network_uuid.stdout }}"

    # Create a security group to hold all rules set in this script.
    - name: Creating {{ security_group_name }} security group for this server
      shell: "{{ openstack }} security group create {{ security_group_name }} --format value -c id"

    # Create the security group rule that allows ping (ICMP traffic).
    - name: Creating the security group rule that allows ping
      shell: "{{ openstack }} security group rule create --ingress --protocol icmp {{ security_group_name }} --format value -c id"
      ignore_errors: yes

    # Create the security group rule that allows ssh (TCP port 22).
    - name: Creating the security group rule that allows ssh
      shell: "{{ openstack }} security group rule create --ingress --protocol tcp --dst-port 22 {{ security_group_name }} --format value -c id"
      ignore_errors: yes

    # Create the security group rule that allows secure HTTP (TCP port 443).
    - name: Creating the security group for secure http
      shell: "{{ openstack }} security group rule create --ingress --protocol tcp --dst-port 443 {{ security_group_name }} --format value -c id"
      ignore_errors: yes

    # Create the floating ip address on the public network.
    - name: Creating a floating ip on the {{ public_network_name }}
      shell: "{{ openstack }} floating ip create {{ public_network_name }} --format value -c floating_ip_address"
      register: floating_ip_address

    # Add a keypair to OpenStack that allows access to the server.
    - name: Creating {{ keypair_name }} keypair to access this server
      shell: "{{ openstack }} keypair create --public-key {{ public_key_path }} {{ keypair_name }} --format value -c fingerprint"

    # Make sure the server flavor is created.
    - name: Creating the flavors
      shell: "{{ openstack }} flavor create --ram {{ item.memory }} --disk {{ item.disk }} --vcpus {{ item.vcpu }} {{ item.name }} --format value -c id"
      with_items: "{{ standard_flavors }} + {{ openshift_flavors }}"
      # Some openstack environments do not allow you to create public flavors.
      ignore_errors: true

    # Download the images that match the checksum.
    - name: Downloading the qcow2 images
      get_url:
        checksum: "{{ item.checksum }}"
        dest: "{{ playbook_dir }}/{{ item.name }}"
        url: "{{ item.url }}"
      with_items: "{{ qcow2_images }}"

    # Check if the file exists and return the checksum.
    - name: Checking for existance of the image in OpenStack
      shell: "{{ openstack }} image show {{ item.name }} --format value -c checksum"
      register: image_checksum
      ignore_errors: true

    # Upload the image to OpenStack
    - name: Uploading the images to OpenStack
      shell: "{{ openstack }} image create {{ item.name }} --disk-format=qcow2 --container-format=bare --file {{ playbook_dir }}/{{ item.name }} --format value -c id"
      with_items: "{{ qcow2_images }}"
      when: image_checksum.rc != 0

    # Optionally delete the local downloaded images.
    - name: Deleting the downloaded qcow2 images
      file:
        path: "{{ playbook_dir }}/{{ item.name }}"
        state: absent
      with_items: "{{ qcow2_images }}"
      when: delete_images == true

    # Create a VM instance with the flavor, image, group, keypair and network.
    - name: Creating a server instance {{ server_name }}
      shell: "{{ openstack }} server create --flavor {{ server_flavor }} --image {{ server_image }} --security-group {{ security_group_name }} --key-name {{ keypair_name }} {{ server_name }} --nic net-id={{ private_network_uuid.stdout }} --format value -c id"
      register: instance_uuid

    # Add the floating ip address to the server.
    - name: Adding the floating ip address {{ floating_ip_address.stdout }} to the server instance
      # This command can fail with: Instance network is not ready yet (HTTP 400)
      shell: "{{ openstack }} server add floating ip {{ server_name }} {{ floating_ip_address.stdout }}"
      register: add_result
      until: add_result.rc == 0
      # Retry 5 times until success.
      retries: 5
      delay: 3
      ignore_errors: yes

    # Use the wait_for module to wait until ssh access can be established.
    - name: Waiting for the server {{ server_name }} to start
      local_action: wait_for
      args:
        host: "{{ floating_ip_address.stdout }}"
        port: 22
        state: started
        delay: 5
        timeout: 300

    # Print out the ssh connection command to the new server.
    - name: Printing the command to connect to the server instance
      debug:
        msg: "ssh -i {{ private_key_path }} {{ server_user }}@{{ floating_ip_address.stdout }}"

    - name: Adding the newly generated floating IP address as the target host
      add_host:
        name: "{{ floating_ip_address.stdout }}"
        groups: [ 'target-host' ]
        ansible_user: "{{ server_user }}"

    - name: Adding the image_server as a new host
      add_host:
        name: "{{ image_server }}"
        groups: [ 'image-server' ]
        ansible_user: "{{ image_server_user }}"

    - name: Writing out the current inventory to make it easier to rerun
      copy:
        content: "[image-server]\n{{ image_server }} ansible_user={{ image_server_user }}\n[target-server]\n{{ floating_ip_address.stdout }} ansible_user={{ server_user }}"
        dest: "./current-inventory"

    # Print out the command to set up the host with Ansible and other prereqs.
    - name: Printing the command for setting up the host to use Ansible
      debug:
        msg: "ansible-playbook install_server_dependencies.yml -v --ssh-common-args='-i {{ private_key_path }}' -i current-inventory"

    # Print out the command to install the OpenStack images.
    - name: Printing the command for copying the OpenStack images
      debug:
        msg: "ansible-playbook find_and_prepare_images.yml -v --ssh-common-args '-i {{ private_key_path }}' -i current-inventory"

    # Print out the command for the OpenStack and OpenShift config and install.
    - name: Printing the command for configuring OpenShift on OpenStack
      debug:
        msg: "ansible-playbook openshift_on_openstack.yml -v --ssh-common-args='-i {{ private_key_path }}' -i current-inventory"

- name: Including the dependency playbook and runing it against the new host
  include: install_server_dependencies.yml

- name: Including the image playbook and running against the dynamic hosts
  include: find_and_prepare_images.yml

- name: Including the OpenShift playbook and running against the target-host
  include: openshift_on_openstack.yml
